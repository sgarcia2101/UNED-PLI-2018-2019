package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token COMMENT;
terminal Token NUMBER;
terminal Token STRING;
terminal Token ID;

// Palabras reservadas
terminal Token BOOLEAN;
terminal Token TRUE;
terminal Token BEGIN;
terminal Token CONSTANTS;
terminal Token OF;
terminal Token IN;
terminal Token RETURN;
terminal Token INTEGER;
terminal Token THEN;
terminal Token WRITE;
terminal Token FALSE;
terminal Token END;
terminal Token FUNCTION;
terminal Token NOT;
terminal Token FOR;
terminal Token PROCEDURE;
terminal Token PROGRAM;
terminal Token IF;
terminal Token ELSE;
terminal Token SUBPROGRAM;
terminal Token TYPES;
terminal Token VAR;
terminal Token VARIABLES;
terminal Token VECTOR;
terminal Token AND;
	
// Delimitadores
terminal Token LEFT_PARENTHESIS;
terminal Token RIGHT_PARENTHESIS;
terminal Token LEFT_BRACKET;
terminal Token RIGHT_BRACKET;
terminal Token COMMA;
terminal Token SEMICOLON;
terminal Token COLON;
terminal Token RANGE;
terminal Token DOT;
	
// Operadores
terminal Token PLUS;
terminal Token ASTERISK;
terminal Token LESS;
terminal Token EQUAL;
terminal Token ASSIGN;
terminal Token VECTOR_ACCESS;


// ...


// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;

non terminal            declaraciones;
non terminal            declaracionConstantes;
non terminal            expresionesConstante;
non terminal            expresionConstante;

non terminal            declaracionVariables;
non terminal            expresionesVariable;
non terminal            expresionVariable;
non terminal            listaExpresionVariable;

non terminal            declaracionTipos;
non terminal            expresionesTipo;
non terminal            expresionTipo;

non terminal            declaracionSubprogramas;
non terminal            declaracionesSubprograma;
non terminal            declaracionSubprograma;
non terminal            declaracionFuncion;
non terminal			declaracionProcedimiento;
non terminal			listaParametrosFuncionAux;
non terminal            listaParametrosFuncion;
non terminal            listaParametrosPasoPorvalor;
non terminal            listaParametrosPasoPorReferencia;
non terminal            parametrosFuncion;
non terminal            listaParametros;

non terminal            sentencias;
non terminal            sentencia;
non terminal            sentenciaEscribir;
non terminal            sentenciaAsignacion;
non terminal            sentenciaReturn;
non terminal			llamadaFuncion;
non terminal            referencia;

non terminal            bloqueIf;
non terminal            bloqueFor;

non terminal            tipos;
non terminal            tiposPrimitivos;
non terminal            parametro;
non terminal			expresion;
non terminal			operador;
non terminal            valorPrimitivo;



// Declaración de relaciones de precedencia
precedence left AND;
precedence left LESS;
precedence left EQUAL;
precedence left PLUS;
precedence left ASTERISK;
precedence left LEFT_BRACKET, RIGHT_BRACKET;
precedence left LEFT_PARENTHESIS, RIGHT_PARENTHESIS;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega de Junio deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= PROGRAM ID COLON declaraciones BEGIN sentencias END DOT;

declaraciones ::= declaracionConstantes declaracionTipos declaracionVariables declaracionSubprogramas;

// declaraciones de constantes
declaracionConstantes ::= CONSTANTS expresionesConstante 
				| ;
expresionesConstante::= expresionConstante expresionesConstante 
				| expresionConstante;
expresionConstante::= ID ASSIGN valorPrimitivo SEMICOLON;

// declaraciones de variables
declaracionVariables ::= VARIABLES expresionesVariable 
				| ;
expresionesVariable::= expresionVariable expresionesVariable 
				| expresionVariable;
expresionVariable ::= listaExpresionVariable COLON tipos SEMICOLON;
listaExpresionVariable ::= ID COMMA listaExpresionVariable | ID;

// declaraciones de tipos
declaracionTipos ::= TYPES expresionesTipo 
				| ;
expresionesTipo::= expresionesTipo expresionTipo 
				| expresionTipo;
expresionTipo::= ID ASSIGN VECTOR LEFT_BRACKET NUMBER RANGE NUMBER RIGHT_BRACKET OF tiposPrimitivos SEMICOLON;

tipos ::= tiposPrimitivos 
				| ID;
tiposPrimitivos ::= INTEGER 
				| BOOLEAN;

// SUBPROGRAMAS
declaracionSubprogramas ::= SUBPROGRAM declaracionesSubprograma 
				| ;
declaracionesSubprograma   ::= declaracionSubprograma 
				| declaracionesSubprograma declaracionSubprograma;

declaracionSubprograma ::= declaracionFuncion 
				| declaracionProcedimiento;
                            
declaracionFuncion ::= FUNCTION ID LEFT_PARENTHESIS listaParametrosFuncionAux RIGHT_PARENTHESIS COLON tiposPrimitivos COLON declaraciones BEGIN sentencias sentenciaReturn END SEMICOLON;

declaracionProcedimiento ::= PROCEDURE ID LEFT_PARENTHESIS listaParametrosFuncionAux RIGHT_PARENTHESIS COLON declaraciones BEGIN sentencias END SEMICOLON;

listaParametrosFuncionAux ::= listaParametrosFuncion SEMICOLON listaParametrosFuncionAux 
				| listaParametrosFuncion;

listaParametrosFuncion ::= listaParametrosPasoPorReferencia | listaParametrosPasoPorvalor;

listaParametrosPasoPorReferencia ::= VAR listaParametrosPasoPorvalor;
				
listaParametrosPasoPorvalor ::=  parametrosFuncion listaParametrosPasoPorvalor 
				| parametrosFuncion;
				
parametrosFuncion ::= listaParametros COLON tipos;

listaParametros ::= expresion COMMA listaParametros | expresion | ;

sentenciaReturn ::= RETURN ID SEMICOLON;


// SENTENCIAS BODY

sentencias ::= sentencia SEMICOLON sentencias 
				| sentencia;
sentencia ::= sentenciaEscribir
				| sentenciaAsignacion
				| bloqueIf
				| bloqueFor
				| llamadaFuncion
				| ;

sentenciaEscribir ::= WRITE LEFT_PARENTHESIS parametro RIGHT_PARENTHESIS;

sentenciaAsignacion ::= referencia ASSIGN expresion;

referencia ::= ID | ID LEFT_BRACKET expresion RIGHT_BRACKET;

parametro ::= STRING 
				| expresion 
				| ;
				
expresion::= referencia 
				| valorPrimitivo 
				| expresion operador expresion 
				| LEFT_PARENTHESIS expresion RIGHT_PARENTHESIS
				| llamadaFuncion;

valorPrimitivo ::= NUMBER | TRUE | FALSE;
				
llamadaFuncion ::= ID LEFT_PARENTHESIS listaParametros RIGHT_PARENTHESIS;

operador::= PLUS 
				| ASTERISK 
				| AND
				| LESS
				| EQUAL;

// BLOQUE IF
bloqueIf ::= IF expresion THEN COLON sentencias END IF
				| IF expresion THEN COLON sentencias ELSE COLON sentencias END IF;
				
// BLOQUE FOR
bloqueFor ::= FOR ID IN expresion RANGE expresion COLON sentencias END FOR;
